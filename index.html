<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI BibTeX Cleaner & Renamer</title>
    <style>
        :root { --primary-color: #2563eb; --bg-color: #f8fafc; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg-color); color: #334155; max-width: 1200px; margin: 0 auto; padding: 20px; }
        h1 { text-align: center; color: #1e293b; margin-bottom: 10px; }
        p.subtitle { text-align: center; color: #64748b; margin-bottom: 30px; }
        
        .container { display: flex; gap: 20px; height: 70vh; }
        .box { flex: 1; display: flex; flex-direction: column; }
        
        label { font-weight: 600; margin-bottom: 8px; display: block; }
        textarea { flex: 1; padding: 15px; border: 1px solid #cbd5e1; border-radius: 8px; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace; font-size: 14px; resize: none; outline: none; transition: border-color 0.2s; }
        textarea:focus { border-color: var(--primary-color); }
        
        .controls { display: flex; justify-content: center; gap: 15px; margin: 20px 0; }
        button { background: var(--primary-color); color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; cursor: pointer; transition: opacity 0.2s; font-weight: 500; }
        button:hover { opacity: 0.9; }
        button.secondary { background: #64748b; }
        
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 10px 20px; border-radius: 4px; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

    <h1>AI BibTeX Cleaner</h1>
    <p class="subtitle">è‡ªåŠ¨ç²¾ç®€å­—æ®µ â€¢ ä¼šè®®åç¼©å†™ â€¢ æ ¼å¼åŒ–å¼•ç”¨ ID (Ren2025TitleCVPR)</p>

    <div class="container">
        <div class="box">
            <label for="input">è¾“å…¥åŸå§‹ BibTeX:</label>
            <textarea id="input" placeholder="è¯·ç²˜è´´ DBLP æˆ– Google Scholar çš„ BibTeX..."></textarea>
        </div>
        <div class="box">
            <label for="output">å¤„ç†ç»“æœ:</label>
            <textarea id="output" readonly placeholder="ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
        </div>
    </div>

    <div class="controls">
        <button onclick="processBibtex()">âš¡ ä¸€é”®è½¬æ¢</button>
        <button class="secondary" onclick="copyResult()">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
    </div>

    <div id="toast" class="toast">å·²å¤åˆ¶åˆ°å‰ªè´´æ¿</div>

<script>
/**
 * æ ¸å¿ƒé…ç½®åŒºåŸŸ
 */
const KEEP_FIELDS = ['author', 'title', 'booktitle', 'journal', 'year', 'pages', 'volume', 'number', 'doi', 'url', 'eprint', 'archiveprefix', 'primaryclass'];

const IGNORE_TITLE_WORDS = new Set(['the', 'a', 'an', 'on', 'in', 'of', 'for', 'and', 'with', 'via', 'to', 'from']);

// ä¸¥æ ¼æŒ‰ç…§ Python é€»è¾‘è½¬å†™çš„æ˜ å°„è¡¨
// æ³¨æ„ï¼šæ­£åˆ™å†™æ³•åœ¨ JS ä¸­ç•¥æœ‰ä¸åŒ (å­—ç¬¦ä¸²è½¬ RegExp)
const VENUE_MAPPING = [
    { regex: /CVPRW|CVPR.*Workshop/i, abbr: 'CVPRW' },
    { regex: /ICLRW|ICLR.*Workshop/i, abbr: 'ICLRW' },
    { regex: /CVPR|Computer Vision and Pattern Recognition/i, abbr: 'CVPR' },
    { regex: /ICCV|International Conference on Computer Vision/i, abbr: 'ICCV' },
    { regex: /ECCV|European Conference on Computer Vision/i, abbr: 'ECCV' },
    { regex: /NeurIPS|NIPS|Neural Information Processing Systems/i, abbr: 'NIPS' }, // é…åˆä½ çš„@String NIPS
    { regex: /ICPR|International Conference on Pattern Recognition/i, abbr: 'ICPR' },
    { regex: /BMVC|British Machine Vision Conference/i, abbr: 'BMVC' },
    { regex: /ACM MM|Multimedia/i, abbr: 'ACMMM' },
    { regex: /ICME|International Conference on Multimedia and Expo/i, abbr: 'ICME' },
    { regex: /ICML|International Conference on Machine Learning/i, abbr: 'ICML' },
    { regex: /ICASSP|International Conference on Acoustics, Speech and Signal Processing/i, abbr: 'ICASSP' },
    { regex: /ICIP|International Conference on Image Processing/i, abbr: 'ICIP' },
    { regex: /ACCV|Asian Conference on Computer Vision/i, abbr: 'ACCV' },
    { regex: /ICLR|International Conference on Learning Representations/i, abbr: 'ICLR' },
    { regex: /IJCAI|International Joint Conference on Artificial Intelligence/i, abbr: 'IJCAI' },
    { regex: /AAAI|Association for the Advancement of Artificial Intelligence/i, abbr: 'AAAI' },
    { regex: /SIGIR|Special Interest Group on Information Retrieval/i, abbr: 'SIGIR' },
    
    // æœŸåˆŠ
    { regex: /TPAMI|Pattern Analysis and Machine Intelligence/i, abbr: 'PAMI' },
    { regex: /IJCV|International Journal of Computer Vision/i, abbr: 'IJCV' },
    { regex: /TOG|Transactions on Graphics/i, abbr: 'TOG' },
    { regex: /TIP|Transactions on Image Processing/i, abbr: 'TIP' },
    { regex: /TVCG|Transactions on Visualization and Computer Graphics/i, abbr: 'TVCG' },
    { regex: /TMM|Transactions on Multimedia/i, abbr: 'TMM' },
    { regex: /CSVT|Circuits and Systems for Video Technology/i, abbr: 'CSVT' },
    { regex: /PR$|Pattern Recognition$/i, abbr: 'PR' },
    { regex: /SPL|Signal Processing Letters/i, abbr: 'SPL' },
    { regex: /Vis\.? Res\.?|Vision Research/i, abbr: 'VR' },
    { regex: /JOV|Journal of Vision/i, abbr: 'JOV' },
    { regex: /TVC|The Visual Computer/i, abbr: 'TVC' },
    { regex: /JCST|Journal of Computer Science and Technology/i, abbr: 'JCST' },
    { regex: /CGF|Computer Graphics Forum/i, abbr: 'CGF' },
    { regex: /CVM|Computational Visual Media/i, abbr: 'CVM' }
];

/**
 * ç®€å•çš„ BibTeX è§£æå™¨ (Regex Based)
 * ä¸ä¾èµ–å¤–éƒ¨åº“ï¼Œè¶³ä»¥å¤„ç†æ ‡å‡† DBLP/Google Scholar æ ¼å¼
 */
function parseBibtex(input) {
    const entries = [];
    // åŒ¹é… @type{key, ...} ç»“æ„
    const entryRegex = /@(\w+)\s*\{([^,]*),([\s\S]*?)(?=@\w+|\s*$)/g;
    
    let match;
    while ((match = entryRegex.exec(input)) !== null) {
        const type = match[1];
        const rawKey = match[2].trim();
        const content = match[3];
        
        const fields = {};
        
        // åŒ¹é… key = {value} æˆ– key = "value" æˆ– key = 123
        const fieldRegex = /(\w+)\s*=\s*[\{"]([\s\S]*?)[\}"](?=\s*,|\s*$)|(\w+)\s*=\s*(\d+)/g;
        let fieldMatch;
        while ((fieldMatch = fieldRegex.exec(content)) !== null) {
            const key = (fieldMatch[1] || fieldMatch[3]).toLowerCase();
            let val = (fieldMatch[2] || fieldMatch[4]);
            
            // æ¸…ç†å€¼ï¼šç§»é™¤æ¢è¡Œå’Œå¤šä½™ç©ºæ ¼
            val = val.replace(/\s+/g, ' ').trim();
            fields[key] = val;
        }
        
        entries.push({ type, key: rawKey, fields });
    }
    return entries;
}

/**
 * æå–æ ‡é¢˜é¦–ä¸ªå®ä¹‰è¯
 */
function getFirstSigWord(title) {
    if (!title) return "Untitled";
    // ç§»é™¤ LaTeX èŠ±æ‹¬å·å’Œéå­—æ¯å­—ç¬¦
    let clean = title.replace(/[\{\}]/g, "").replace(/[^\w\s]/g, "");
    let words = clean.split(/\s+/);
    
    for (let w of words) {
        if (!IGNORE_TITLE_WORDS.has(w.toLowerCase())) {
            return w.charAt(0).toUpperCase() + w.slice(1);
        }
    }
    return words[0] ? (words[0].charAt(0).toUpperCase() + words[0].slice(1)) : "Untitled";
}

/**
 * ä¸»å¤„ç†é€»è¾‘
 */
function processBibtex() {
    const input = document.getElementById('input').value;
    const parsedEntries = parseBibtex(input);
    let resultString = "";

    // æŒ‰ç”Ÿæˆçš„æ–° ID æ’åº
    const processedEntries = parsedEntries.map(entry => {
        const newEntry = { type: entry.type, fields: {} };
        
        // 1. å­—æ®µè¿‡æ»¤
        KEEP_FIELDS.forEach(f => {
            if (entry.fields[f]) newEntry.fields[f] = entry.fields[f];
        });

        // 2. ä¼šè®®åæ˜ å°„
        let venueAbbr = "CONF";
        let venueFull = newEntry.fields['booktitle'] || newEntry.fields['journal'] || "";
        
        let found = false;
        if (venueFull) {
            for (let item of VENUE_MAPPING) {
                if (item.regex.test(venueFull)) {
                    // æ›¿æ¢å­—æ®µå€¼
                    if (newEntry.fields['booktitle']) newEntry.fields['booktitle'] = item.abbr;
                    if (newEntry.fields['journal']) newEntry.fields['journal'] = item.abbr;
                    
                    // å¦‚æœåŸæœ¬æ˜¯ journal ä½†åŒ¹é…åˆ°äº†ä¼šè®®ç¼©å†™ï¼Œæ¸…ç†å†—ä½™
                    if (newEntry.fields['journal'] && !newEntry.fields['booktitle'] && item.abbr === newEntry.fields['journal']) {
                        // ä¿æŒ journal å­—æ®µ
                    }
                    
                    venueAbbr = item.abbr;
                    found = true;
                    break;
                }
            }
            if (!found) {
                // Fallback: å–éç‰¹æ®Šå­—ç¬¦çš„ç¬¬ä¸€ä¸ªè¯
                let simple = venueFull.replace(/[^{}\w\s]/g, "");
                venueAbbr = simple.split(/\s+/)[0] || "CONF";
            }
        }

        // 3. ç”Ÿæˆæ–° ID
        // ä½œè€…
        let authors = (newEntry.fields['author'] || "Unknown").split(/\s+and\s+/);
        let firstAuthor = authors[0].trim();
        let lastName = firstAuthor.includes(',') ? firstAuthor.split(',')[0].trim() : firstAuthor.split(/\s+/).pop();
        lastName = lastName.replace(/\W+/g, "");
        
        // å¹´ä»½
        let year = newEntry.fields['year'] || "0000";
        
        // æ ‡é¢˜è¯
        let titleWord = getFirstSigWord(newEntry.fields['title']);
        
        newEntry.id = `${lastName}${year}${titleWord}${venueAbbr}`;
        
        return newEntry;
    });

    // æ’åº
    processedEntries.sort((a, b) => a.id.localeCompare(b.id));

    // ç”Ÿæˆæœ€ç»ˆ BibTeX å­—ç¬¦ä¸²
    processedEntries.forEach(entry => {
        resultString += `@${entry.type}{${entry.id},\n`;
        
        // æŒ‰ key å­—æ¯é¡ºåºè¾“å‡ºå­—æ®µ
        Object.keys(entry.fields).sort().forEach(key => {
            let val = entry.fields[key];
            // å¦‚æœæ˜¯ç¼©å†™ï¼ˆå…¨å¤§å†™ä¸”ä¸å«ç©ºæ ¼ï¼‰ï¼Œé€šå¸¸ä¸åŠ èŠ±æ‹¬å·ï¼Œä½†ä¸ºäº†å…¼å®¹æ€§ï¼Œè„šæœ¬è¿™é‡Œç»Ÿä¸€åŠ ä¸ŠèŠ±æ‹¬å·
            // é™¤éæ˜¯ç‰¹å®šçš„ keysã€‚ä½ ä¹‹å‰è¦æ±‚ booktitle = {CVPR}ï¼Œæ‰€ä»¥è¿™é‡Œç»Ÿä¸€ä¿ç•™èŠ±æ‹¬å·ã€‚
            resultString += `  ${key.padEnd(12)} = {${val}},\n`;
        });
        
        // ç§»é™¤æœ€åä¸€ä¸ªé€—å·
        resultString = resultString.replace(/,\n$/, "\n");
        resultString += `}\n\n`;
    });

    document.getElementById('output').value = resultString;
}

function copyResult() {
    const output = document.getElementById('output');
    output.select();
    document.execCommand('copy');
    
    const toast = document.getElementById('toast');
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 2000);
}
</script>

</body>
</html>